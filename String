#include <iostream>
#include <cstring>


using namespace std;
class String
{
    char *str;
    int len;
public:
    String(int l = 0); // конструктор по умолчанию
    String(const char *s); // конструктор копирует содержимое переданной строки
    String(const String &s); // конструктор копирования: создаёт копию объекта String
    ~String() { //деструктор ++
        if(str) delete []str; str = NULL;
    }
    int strLength(); // длина строки
    String & operator = (const String &s2); // ++
    char &operator [](int i){ //возвращает i-ый элемент строки ++
        return str[i];
    }
    bool operator == (String &s); // ++
    bool operator != (String &); // ++
    String operator + (const String &s2); // ++
    String & operator += (const String &s2); // к первой строке приписываем вторую и возвращвем первую
    friend istream & operator >> (istream &is, String &s); // ++
    friend ostream & operator << (ostream &os, String &s); // ++
    int BMSearch(String &);
};
String::String(int l){ // конструктор по умолчанию ++
    str = new char[l];
    len = 0;
    str[0] = '\0';
}
String::String(const char *s){ // конструктор копирует содержимое переданной строки ++
    str = new char[strlen(s) + 1];
    for(len = 0; s[len] != 0; len++){
        str[len] = s[len];
    }
    str[len] = '\0';
}
String::String(const String &s){
    str = new char[s.len + 1];
    for (len = 0; len <= s.len; str[len] = s.str[len], len++){
        len--;
    }
}
String &String::operator = (const String &s2){
    if(this == &s2) return *this;
    delete []str;
    len = s2.len;
    str = new char [len + 1];
    strcpy(str, s2.str);
    return *this;
}
bool String ::operator == (String &s){
    return strcmp(str, s.str) == 0;
}
bool String ::operator != (String &s){
    return strcmp(str, s.str) != 0;
}
String String::operator + (const String &s2){
    String rez(len + s2.len + 1);
    strcpy(rez.str, str);
    strcat(rez.str, s2.str);
    return rez;
}
String &String::operator += (const String &s2){
    len += s2.len;
    char *t = new char[len + 1];
    strcpy_s(t, len+1, str);
    strcat_s(t, len + 1, s2.str);
    delete []str;
    str = t;
    return *this;
}
int String::strLength(){
    return len;
}
istream & operator >> (istream &is, String &s){
    char temp[1000];
    is >> temp;
    s = String(temp);
    return is;
}
ostream & operator << (ostream &os, String &s){
    os << s.str;
    return os;
}
int String::BMSearch(String &obr){
    int temp[256];
    int lp = obr.len;
    int ls = len;
    if (lp > ls){
        return -1;
    }
    for(int i = 0; i < 256; temp[i] = lp, i++){
        for (int i = 0; i < lp - 1; i++){
            temp [obr[i]] = lp - i - 1;
        }
    }
    int i = lp - 1;
    int j = i;
    while(j >= 0){
        if (j < 0){
            return i + 1 - lp;
        }
        int k = i;
        j = lp - 1;
        while (j >= 0) {
            if(str[k] == obr[j]){
                j--;
                k--;
            }
            else{
                i += temp[str[i]];
                j = lp - 1;
                break;
            }
        }
    }
    if (j >= 0){
        return -1;
    }
    return i + 1 - lp;
}
int main()
{
    String s1("На дворе трава на траве дрова");
    String s2("траве");
    cout << "s1 = " << s1 << "\n";
    cout << "s2 = " << s2 << "\n";
    String s3 = s1 + s2;
    cout << "s3 = " << s3 << "\n";
    String s4("gfhyrgtdh");
    s3 += s4;
    cout << "s4 = " << s3 << "\n";
    if(s1 == s3){

    }
}
