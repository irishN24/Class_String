#include <iostream>
#include <cstring>

using namespace std;

class String
{
    char* str; // указатель на массив символов
    int len; // длина строки
public:
    String(int l = 0); // конструктор по умолчанию
    String(const char* s); // конструктор копирует содержимое переданной строки
    String(const String& s); // конструктор копирования: создаёт копию объекта String
    ~String() { //деструктор
        delete[]str;
    }
    int strLength() const; // длина строки
    String& operator = (const String& s2); // присваивание
    char& operator [](int i) const { //возвращает i-ый элемент строки
        return str[i];
    }
    bool operator == (const String& s) const; // оператор равенства
    bool operator != (const String& s) const; // оператор неравенства
    String operator + (const String& s2) const; // оператор конкатенации
    String& operator += (const String& s2); // оператор конкатенации
    friend istream& operator >> (istream& is, String& s); // ввод
    friend ostream& operator << (ostream& os, const String& s); // вывод
    int BMSearch(const String&) const; // БМ поиск
};

String::String(int l) { // конструктор по умолчанию
    str = new char[l + 1]; // выделяем память l+1
    len = 0; // устанавливаем длину по умолчанию 0
    str[0] = '\0';
}
String::String(const char* s) { // конструктор копирует содержимое переданной строки
    if (s == nullptr) { //создаём пустую строку
        len = 0;
        str = new char[1];
        str[0] = '\0';
    }
    else { // выделяет длину s, память и копирует строку
        len = strlen(s);
        str = new char[len + 1];
        strcpy_s(str, len + 1, s);
    }
}
String::String(const String& s) { //конструктор копирования
    len = s.len; // копируем длину
    str = new char[len + 1]; // выделяем память
    strcpy_s(str, len + 1, s.str); // копируем содержимое из s
}
int String::strLength() const { //возвращает длину строки
    return len;
}
String& String::operator = (const String& s2) { // присванивание
    if (this == &s2) return *this; //проверка: не присваиваем ли самому себе
    delete[]str; // освобождаем память, выделенную под строку
    len = s2.len;
    str = new char[len + 1];
    strcpy_s(str, len + 1, s2.str);
    return *this;
}
bool String::operator == (const String& s) const { //равенство
    return strcmp(str, s.str) == 0;
}

bool String::operator != (const String& s) const { // неравенство
    return strcmp(str, s.str) != 0;
}
String String::operator + (const String& s2) const { // конкатенация
    String rez(len + s2.len + 1); // новый объект с длиной s + s2;
    rez.len = len + s2.len;
    strcpy_s(rez.str, rez.len + 1, str);
    strcat_s(rez.str, rez.len + 1, s2.str);
    return rez;
}
String &String::operator+=(const String& s) { //конкатенация
    char *t = new char[len + 1]; // буфер
    strcpy_s(t, len + 1, str); // копируем в буфер строку
    delete[] str; // освобождаем память, выделенную под строку
    len = len + s.len; // новая память для объединённой строки
    str = new char[len + 1];
    strcpy_s(str, len + 1, t);
    strcat_s(str, len + 1, s.str);
    delete[] t; // освобождаем память в буфере
    return *this;
}
istream& operator >> (istream& is, String& s) { // дружественный опрератор ввода (не работает)
    char temp[1000]; // буфер
    is >> temp;
    s = String(temp);
    return is;
}

ostream& operator << (ostream& os, const String& s) { // дружественный оператор вывода
    os << s.str;
    return os;
}

int String::BMSearch(const String& obr) const { // БМ поиск
    int temp[256]; // таблица смещений
    for (int i = 0; i < 256; i++) {
        temp[i] = obr.len;
    }
    for (int i = 0; i < obr.len - 1; i++) {
        temp[obr[i]] = obr.len - 1 - i;
    }
    int i = obr.len - 1;
    int j = obr.len - 1;
    while (i < len) {
        int k = i;
        while (j >= 0 && str[k] == obr[j]) {
            k--;
            j--;
        }
        if (j == -1) {
            return k + 1;
        }
        else{
            i += temp[str[i]];
        }
    }
    return -1;
}

int main()
{
    String s1("Do not cross the bridge until you come to it.");
    String s2;

    cout << "s1 = " << s1 << "\n";

    cout << "s2 = ";
    cin >> s2;
    String s3 = s1 + s2;
    cout << "s3 = " << s3 << "\n";
    String s4("jghtyufjsdbacaf");
    s4 += s3;
    cout << "s4 = " << s4 << "\n";
    if (s1 == s3) {
        cout << "s1 == s3\n";
    }
    else {
        cout << "s1 != s3\n";
    }

    String s6("If it is not broke, don’t fix it.");
    String sBM("bro");
    int index = s6.BMSearch(sBM);
    String sBM2("aaaa");
    int index2= s6.BMSearch(sBM2);
    cout << "BM Search (bro): " << index << std::endl;
    cout << "BM Search (aaaa): " << index2 << std::endl;
    return 0;
}
